[[{"l":"코알라코딩"},{"i":"coalacoding","l":"@coalacoding"},{"l":"리액트노트 페이지 입니다","p":["완성프로젝트 미리보기"]}],[{"l":"목차","p":["1. 리액트설치","1.1. React소개","1.1.1. 리액트란?","1.1.2. 리액트","1.1.3. 리액트 참조문서","1.1.4. 탄생배경","1.1.5. SPA vs MPA","1.1.5.1. SPA vs MPA 비교표","1.1.5.2. MPA 개발툴 종류","1.2. React 주요개념","1.2.1. 컴포넌트","1.2.2. 가상DOM","1.2.3. 빌드","1.3. React 개발환경 설치","1.3.1. Node 설치","1.4. 리액트 앱 설치","1.5. 리액트앱 수정"]},{"l":"1. 리액트설치"},{"i":"11-react소개","l":"1.1. React소개"},{"i":"111-리액트란","l":"1.1.1. 리액트란?","p":["JavaScript 라이브러리","UI(사용자 인터페이스)를 만들기 위해 Facebook에서 개발.","페이스북과 개발자,기업,단체에 의해 유지보수됨.","리액트는 싱글 페이지 애플리케이션 이나 모바일 애플리케이션 개발에 사용되기도 함."]},{"i":"112-리액트","l":"1.1.2. 리액트","p":["리액트는 javascript extension JSX 라는 자바스크립트 확장문법을 사용한다.","웹브라우저에서는 바로 JSX를 해석할수 없으며 바벨이라는 트랜스컴파일러를 이용해서 자바스크립트로 변환후 웹 브라우저에 적용한다.","https://babeljs.io/repl 에서 변환되는 과정을 볼수있다"]},{"i":"113-리액트-참조문서","l":"1.1.3. 리액트 참조문서","p":["공식문서"]},{"i":"114-탄생배경","l":"1.1.4. 탄생배경","p":["웹페이지는 HTML,CSS,JS 파일로 구성되며 일반적으로 아래와 같이 만들어 진다.","기본 웹페이지","점점 웹이 복잡해 지면서 파일의 갯수와 코드의 수가 길어지며 유지보수가 어려워지기 시작했다. 오류발생시 수천 줄의 코드를 확인해야 할 경우도 있고 코드끼리 의존성<a id=\"fnref:1\" href=\"#fn:1\" class=\"footnote-ref\"><sup>1</sup></a> 이 깊어지고 복잡해졌다. 또한 수많은 javascript 라이브러리를 불러와서 사용하다 보니 라이브러리 객체들끼리 이름이 같아 충돌하는 경우도 있고 관리가 어려워 졌다.","근대의 웹페이지","React 는 여러 html 문서를 단일 js파일을 사용해 개발할수 있어 이런 문제가 개선되었다."]},{"i":"115-spa-vs-mpa","l":"1.1.5. SPA vs MPA","p":["리액트를 접하다 보면 종종 SPA와 MPA 라는 단어를 만나게 된다.","외국어 이다 보니 굉장히 어렵고 낮설게 느껴지는데 두개의 차이점을 짚어보자.","spa VS mpa"]},{"i":"1151-spa-vs-mpa-비교표","l":"1.1.5.1. SPA vs MPA 비교표","p":["MPA (멀티 페이지 애플리케이션)","SEO","SPA (싱글 페이지 애플리케이션)","SPA와 MPA는 웹 애플리케이션 프로젝트의 목적, 요구사항, 개발 리소스 등을 고려하여 선택해야 한다.","가상 DOM을 활용하여 초기 로딩 이후 성능 향상됨(메모리 사용량은 높아질 수 있음).","각각의 페이지가 독립적으로 로드되기 때문에 초기 로딩 시간이 빠름.","개발 및 유지보수","개별 페이지를 쉽게 크롤링하고 인덱싱할 수 있어 SEO에 유리함.","검색 엔진 최적화(SEO)를 위해 추가 작업 필요할 수 있음.","구분","네비게이션 시 전체 페이지 리로드로 인해 서버 요청량 및 네트워크 트래픽 증가함.","네트워크 트래픽","단일 HTML 페이지에서 동적으로 콘텐츠를 업데이트하는 웹 애플리케이션.","로딩 시간","사용자 경험","서버 쪽에서 각각의 페이지를 처리하기 때문에 복잡성과 비용 발생 가능성 있음.","설명","성능","여러 개의 HTML 페이지로 구성된 웹 애플리케이션.","재사용 가능한 컴포넌트와 클라이언트 사이드 라우팅으로 개발 및 유지보수가 간단함.","전체 페이지 리로드 없이 빠른 응답 속도와 부드러운 사용자 인터랙션 제공.","전체 페이지 리로드로 인해 성능 저하될 수 있으나 메모리 사용량은 낮아짐.","초기 로딩 시간은 모든 리소스를 한 번에 로드하기 때문에 오래 걸릴 수 있음.","초기 로딩 이후 서버 요청을 줄여 네트워크 트래픽을 절약함.","페이지 전환 시 약간의 지연과 중단이 발생할 수 있음."]},{"i":"1152-mpa-개발툴-종류","l":"1.1.5.2. MPA 개발툴 종류","p":["React 리액트","Vue 뷰","Angual 앵귤러","..."]},{"i":"12-react-주요개념","l":"1.2. React 주요개념","p":["[컴포넌트]","[가상DOM]","[빌드]"]},{"i":"121-컴포넌트","l":"1.2.1. 컴포넌트","p":["여러번 사용되는 UI를 태그로 만들어서 사용하는 기술","자바스크립트와 유사하게 생긴 jsx 라는 문법을 사용","네이버 또한 리액트로 개발 되었으며 컴포넌트를 확인할수 있다 아래의 블록은 네이버의 컴포넌트 단위이다. 네이버의 컴포넌트 네이버의 컴포넌트"]},{"i":"122-가상dom","l":"1.2.2. 가상DOM","p":["javascript로 구현된 화면을 그리기 위해 사용하는 DOM 대신 리액트에서는 VirtualDOM 을 사용한다.","우리는 Javascript 를 사용한 개발시 DOM 을 활용하였다. DOM과 VirtualDOM 은 뭐가 다를까?","DOM(문서 객체 모델): 웹 페이지의 객체를 표현하는 방식으로, HTML 및 XML 문서를 계층적 트리 구조로 만들어 JavaScript나 다른 프로그래밍 언어가 DOM 구조에 접근하여 문서 구조, 스타일, 내용 등을 변경할 수 있게 하는 것이다.","문제점: 대규모 웹 애플리케이션에서는 수많은 데이터와 요소가 동적으로 변화하며 이 때 매번 DOM 조작이 일어나면 성능상 이슈가 발생한다. 이는 브라우저가 CSS 연산, 레이아웃 구성(re-flow), 웹 페이지 다시 그리기(repaint) 등의 작업을 수행해야 하기 때문이다.","Virtual DOM: 이러한 문제를 해결하기 위해 리액트는 가상 DOM 개념을 도입하였다. 가상 DOM은 실제 DOM의 가벼운 사본으로 메모리 상에 존재하며, 데이터 업데이트 시 실제 DOM에 직접 반영하는 대신 가상 DOM에서 처리한다.","동작 방식: 데이터 업데이트 시 전체 UI를 Virtual DOM에 리렌더링한다. 이전 Virtual DOM과 현재 Virtual DOM을 비교(diffing)한다. 바뀐 부분만 실제(DOM에 적용(Reconciliation)한다. 따라서 리액트는 지속적으로 데이터가 변화하는 대규모 애플리케이션 구축에 최적화되어 있다고 볼 수 있다."]},{"i":"123-빌드","l":"1.2.3. 빌드","p":["리액트는 자바스크립트로 웹을 개발하는 기술이다. 웹브라우저는 html만 이해할수 있으므로 결국은 리액트로 개발한 페이지는 html 형식으로 빌드하는 과정을 거쳐야 한다.","빌드과정"]},{"i":"13-react-개발환경-설치","l":"1.3. React 개발환경 설치","p":["앞서 설명했듯 리액트 개발시 빌드라는 과정이 필요하다.","빌드는 웹팩이라는 번들러 (자바스크립트로 개발한 웹페이지를 html로 변환해주는 툴) 를 사용하게 된다. 아래는 웹팩의 공식 문서 링크이다. 웹팩공식문서> 환경설정 을 확인해보자. 어디에 있는 파일을 어디로 저장해야 하는지에 대한 환경 설정을 어떻게 하라고 적혀있다. 웹팩은 쉽게 말하자면 자바스크립트 문서 내에 html 뿐 아니라 웹서비스에 필요한 모든 리소스 파일을 모두 넣어 개발한후 (그것이 가능합니다) 실제 웹서비스가 가능한 html 로 해석해주는 도구이다. 아래의 그림을 보면 쉽게 이해할수 있을것이다.","참 잘그렸죠?","웹팩으로 개발해보면 리액트의 동작 방식이 더욱 잘 이해되므로 공부해보길 추천한다."]},{"i":"131-node-설치","l":"1.3.1. Node 설치","p":["NodeJs 는 구글에서 개발한 자바스크립트를 웹브라우저가 아닌 다른 환경에서도 사용할수 있도록 하는 실행환경이다. NodeJs 에는 NPM(NodejsPackageManager) 이라는 모듈이 포함되어 있는데 이 모듈에 웹팩이 포함되어 있다. 또한 리액트 프로젝트 개발시 기본 환경을 설정을 쉽게 도와주는 코드(boilerplate)가 있어 1.3 과정의 웹팩 환경설정에서 본 것처럼> 복잡한 과정을 거치지 않아도 된다.","NODEJS 를 설치하여 진행한다.","NodeJS 설치이유","nodejs","LTS 버전(가장 안전한 버전)을 설치한다.","node.js를 설치하면 npm은 같이 설치됨","설치확인은 비주얼 코드 실행후 터미널을 열고 아래의 명령어를 입력한다.","[VSCode에서 터미널 창 열기 ]","윈도우 : ctrl + j","맥 : cmd + j"]},{"i":"14-리액트-앱-설치","l":"1.4. 리액트 앱 설치","p":["컴퓨터에 빈폴더 생성","이때 폴더의 경로나 폴더명에 한글,특수문자가 표함되어 있으면 안돼요","리액트 앱의 폴더명은 케밥케이스로 작성합니다","예) react-app, my-app, project-1","vscode 실행","vscode에서 터미널 실행","단축키 : ctrl + J","터미널 창에 명령어 입력","npx create-react-app ."]},{"i":"15-리액트앱-수정","l":"1.5. 리액트앱 수정","p":["src/App.js 의 내용을 수정하면 화면에 바로 반영된다","의존성 은 소프트웨어 개발에서 한 요소가 다른 요소에게 종속되어 있는 관계를 의미한다.예를 제이쿼리를 사용하여 개발한 웹페이지의 경우 해당 페이지는 제이쿼리에 의존적이다.<a href=\"#fnref:1\" class=\"footnote-back-ref\">&#8617;</a>"]}],[{"l":"2-컴포넌트"},{"l":"목차","p":["1. 리액트컴포넌트","1.1. 리액트 앱 실행명령어","1.2. 이미지 리소스 주소","1.3. 컴포넌트의 조건","1.4. 컴포넌트 만들기","1.5. 컴포넌트 규칙","1.5.1. Fragment","1.6. 컴포넌트 내보내기","1.7. Mission","2. 망고회원앱 만들기","2.1. 스타일 파일 다운로드","2.2. 작성"]},{"l":"1. 리액트컴포넌트"},{"i":"11-리액트-앱-실행명령어","l":"1.1. 리액트 앱 실행명령어","p":["npm start"]},{"i":"12-이미지-리소스-주소","l":"1.2. 이미지 리소스 주소","p":["아래의 주소 중 하나를 복사해서 사용하세요","node_modules: 의존성 파일이 저장되는 폴더입니다.","package.json 에 각 파일의 정보가 기록되어 있습니다.","src : 실제 소스 코드가 위치하는 곳입니다","public : 정적인 리소스와 HTML 템플릿 파일(index.html)이 위치합니다. 이곳에 있는 파일은 빌드 시 자동으로 결과물에 포함됩니다","package.json : 프로젝트 정보와 종속성(dependency) 관리를 위한 설정 파일입니다.","package.lock.json : package.json 보다 자세한 정보가 기록된 설정파일로 시스템에서 관리하는 파일입니다. 임의로 수정하시면 오류가 발생할수 있습니다..","App.js : 최상위 컴포넌트","리액트는 작은 컴포넌트 단위로 이루어 지는데 App 컴포넌트는 이런 작은 모듈들을 모두 모아주는 최상위 컴포넌트입니다.","index.js : ReactDOM.render() 함수를 사용하여 최상위 컴포넌트(App 컴포넌트)를 실제 DOM에 마운팅(mounting)합니다. 엔트리포인트는 앱의 시작점으로서, 주로 라우팅 설정, 상태 관리 등의 초기화 작업도 이곳에서 수행될 수 있습니다","이 파일에서 ReactDOM.render() 함수는 public 폴더의 index.html 문서의 실제 DOM 과 리액트 DOM 과 연결하는 역할을 합니다.","아래의 코드는 App 컴포넌트를 DOM에 넣어 화면에 그리겠다는 의미 입니다.","index.js"]},{"i":"13-컴포넌트의-조건","l":"1.3. 컴포넌트의 조건","p":["컴포넌트가 화면에 보여지는 것을 렌더링(Rendering) 이라고 합니다","우선 src 폴더의 App.js 파일을 열어서 소스를 분석해 보겠습니다.","컴포넌트의 조건","함수(클래스)로 구성되어 있다.","반드시 UI 요소(태그랑 비슷하게 생김)를 return 해야 한다.","이름이 대문자로 시작한다.","외부에서 임포트 할수 있도록 반드시 export 한다"]},{"i":"14-컴포넌트-만들기","l":"1.4. 컴포넌트 만들기","p":["컴포넌트는 포함관계를 가질수 있으며 위계에 따라 부모와 자식으로 나뉘어집니다.","간단한 컴포넌트를 생성해봅시다.","src 폴더 하위에 Child.js 생성","src / App.js 열기"]},{"i":"15-컴포넌트-규칙","l":"1.5. 컴포넌트 규칙","p":["컴포넌트는 다른 컴포넌트를 포함할수 있으나 컴포넌트 내부에 다른 컴포넌트를 정의하면 안됩니다.","최상위 요소는 유일 해야 합니다.","막음 태그가 없을 경우 / 를 반드시 작성합니다"]},{"i":"151-fragment","l":"1.5.1. Fragment","p":["최상위 요소를 래핑해야 하는 조건 때문에 구조가 복잡해 질수 있습니다.","이때 사용할수 있는것이 Fragment 입니다.","ReactFragment","컴파일 이후에도 불필요한 div 요소가 생성되지 않습니다.","root 하위 요소를 잘 살펴보세요","Fragment 는 / 빈 태그로도 작성할수 있습니다. 이렇게요","불필요한 div 요소가 생성 됩니다."]},{"i":"16-컴포넌트-내보내기","l":"1.6. 컴포넌트 내보내기","p":["App 컴포넌트에서 임포트 하기","export { 컴포넌트명 }","export default 컴포넌트명","import { 컴포넌트명 } from './컴포넌트명.js';","import 컴포넌트명 from './컴포넌트명.js';","import 할때","Member 컴포넌트를 외부로 내보내기","Picture 컴포넌트를 작성후 외부로 내보내기","당연히 쉽게 꺼내어 쓸수 있도록 컴포넌트를 작성해야 합니다.","모던자바스크립트튜토리얼","반복 사용해야 하는 UI요소 이므로","의미","이번에는 컴포넌트를 내보내는 문법을 알아보겠습니다.","종류","컴포넌트 내보내는 2가지 방법","컴포넌트는 쉽게 태그를 함수로 만들어서 반복 사용하기 위해 개발된 기술 이라고 생각합시다.","파일에서 컴포넌트를 여러개 내보내는 경우","파일에서 컴포넌트를 한개만 내보내는 경우"]},{"i":"17-mission","l":"1.7. Mission","p":["자신만의 컴포넌트를 만들어보세요"]},{"l":"2. 망고회원앱 만들기"},{"i":"21-스타일-파일-다운로드","l":"2.1. 스타일 파일 다운로드","p":["css파일다운로드"]},{"i":"22-작성","l":"2.2. 작성","p":["스타일 파일을 다운로드 하여 src 폴더 하위에 압축을 풉니다.","index.css 파일을 열고 코드를 수정합니다.","src 폴더에 MemberItem.js 파일을 생성후 아래의 코드를 작성합니다.","src 폴더에 MemberItem.css 파일을 생성후 아래의 코드를 작성합니다.","src 폴더의 App.js 파일을 열고 코드를 수정합니다."]}],[{"l":"3-props"},{"l":"1. 리액트 props"},{"i":"11-데이터의-동적출력","l":"1.1. 데이터의 동적출력","p":["리액트에서 컴포넌트를 생성하는 문법을 JSX(JavaScript XML: Javascript에 XML을 추가한 확장한 문법) 라고 합니다.","jsx 에는 {} 기호 안에 자바스크립트 를 작성하면 자바스크립트 코드를 실행할수 있습니다.","MemberItem 컴포넌트에서 사용하고 있는 데이터를 자바스크립트의 표현식으로 변경하여 작성해보겠습니다."]},{"i":"111-작성","l":"1.1.1. 작성","p":["App.js 에 MemberDB 변수를 생성하고 회원정보를 넣어 초기화 합니다","components/MemberItem.js 를 수정합니다.","MemberItem 컴포넌트를 한개만 남기고 삭제합니다.","props 라는 기능을 사용하면 됩니다.","props 란 부모 컴포넌트가 자식 컴포넌트에게 전달하는 데이터를 의미하는데요.","props 를 사용하면 컴포넌트간의 데이터를 공급할수 있습니다.","Props 를 작성합니다.","props 를 진행하기 위해 앱의 구조를 변경하겠습니다.","만약 App.js에서 MemberItem 컴포넌트를 여러번 사용한다면 어떻게 해야할까요?","매번 긴 속성을 작성하지 않아도 되니 정말 편리하죠?","실행화면","실행화면:::","여러번 같은 리스트를 반복할수 있습니다 너무 편리하죠?","지금부터 props를 사용하여 목록마다 다른 데이터를 출력해보도록 하겠습니다.","하위 컴포넌트에 데이터를 전달합니다.","하지만 MemberItem 컴포넌트의 콘텐츠의 내용이 다를 경우 어떻게 해야 할까요?"]},{"i":"222-memberitemjs","l":"2.2.2. MemberItem.js","p":["alt","alt:::","App에서 전달받은 데이터는 MemberItem 컴포넌트에서 각각 자식 컴포넌트로 나누어 전달하게 됩니다.","components/ItemDesc.js 를 생성하고 함수형 컴포넌트로 만듭니다. 이때 매개변수에 props 를 작성합니다.","components/ItemThumb.css 를 생성하고 임포트 합니다.","components/ItemThumb.js 를 생성하고 함수형 컴포넌트로 만듭니다. 이때 매개변수에 props 를 작성합니다.","components/MemberItem.css 에서 설명을 표시하는 css를 잘라 붙입니다.","components/MemberItem.css 에서 이미지를 표시하는 css를 잘라 붙입니다.","components/MemberItem.js 에서 설명을 표시하는 코드를 잘라 붙입니다.","components/MemberItem.js 에서 이미지를 표시하는 코드를 잘라 붙입니다.","MemberItem 컴포넌트를 아래의 이미지처럼 두개로 나누어 보겠습니다.","MemberItem 컴포넌트에 ItemThumb,ItemDesc 컴포넌트를 임포트 합니다.","ul.list_bodyli.list_item((.list_imgimg)+(.list_descspan.title+span+text)) 의 구조만 남기고 모두 삭제 합니다","각 컴포넌트로 App 에서 공급받은 데이터를 다시 전달합니다.","그렇기 때문에 컴포넌트를 세분화 하여 개발하게 될 경우 각 컴포넌트의 독립성을 유지하게 되며 코드의 재사용성이 높아집니다.","다음 데이터를 전달합니다.","데이터의 구조가 변경 되었으므로 components 폴더의 MemberList 컴포넌트의 코드를 수정합니다.","리액트의 앱은 기존 html 문서처럼 하나의 페이지로 구성되는 것이 아니라 컴포넌트가 모여서 페이지를 구성하는 방식입니다.","변수 member 삭제 합니다","부모컴포넌트가 전달하는 데이터를 매개변수로 전달 받습니다.","여기까지 작성시 이메일은 렌더되지 않습니다.","이때 작성한 props 는 리액트에서 제공하는 기능으로 상위 요소가 전달하는 모든 데이터를 공급받을수 있습니다.","콘솔로그를 보면 App 에서 전달하고 있는 데이터가 확인됩니다."]},{"i":"35-itemdescjs","l":"3.5. ItemDesc.js","p":["itemDesc 컴포넌트에서 props를 확인해봅시다.","전달되는 데이터를 확인후 email 을 추가합니다.","최상위 요소는 한개만 반환해야 하므로 빈 태그를 추가합니다."]},{"l":"4. Misson","p":["item목록을 표시하는 컴포넌트를 생성하세요","아래의 표시된 부분을 컴포넌트로 분리하세요","alt","App 컴포넌트의 데이터를 생성한 컴포넌트로 전달하세요"]},{"i":"41-missonexplan","l":"4.1. MissonExplan","p":["key","map 함수를 사용하면 같은 컴포넌트를 반복 하여 여러번 만들수 있습니다.","이때 react 에서 같은 컴포넌트를 식별할수 있는 고유의 식별자가 필요한데 이것을 key 속성으로 지정합니다.","key 속성을 작성하지 않거나 key의 값이 중복될 경우 에러 메시지가 확인됩니다.","키값이 중복되었을 경우 오류 메시지"]},{"l":"Step 1","p":["App.js 수정"]},{"l":"Step 2","p":["MemberItem 컴포넌트 작성","콘솔창에 props를 출력해보면 App에서 전달하는 db의 값이 배열로 전달되는것을 알수 있습니다.","배열 이므로 각 요소의 인덱스 번호를 사용하여 하위 컴포넌트인 MemberItemList 로 데이터를 분리하여 전달합니다.","위의 코드는 아래와 같이 수정할수 있습니다.","map() 함수는 자바스크립트의 내장함수로 배열의 요소를 한번씩 순회하여 실행한후 새 배열로 반환합니다.","실행화면","이렇게 하면 위와 같은 실행화면이 확인됩니다."]}],[{"l":"4-event"},{"l":"1. event"},{"i":"11-react-event-listener","l":"1.1. React Event Listener","p":["onBlur","onChange","onClick","onFocus","onKeyDown","onKeyUp","onMouseLeave","onMouseOver","onScroll","onSubmit","마우스 클릭 이벤트를 처리합니다.","설명","스크롤 이벤트를 처리합니다.","요소 위로 마우스 커서가 올라갈 때 발생합니다.","요소가 포커스를 받았을 때 발생합니다.","요소가 포커스를 잃었을 때 발생합니다.","요소에서 마우스 커서가 벗어날 때 발생합니다.","이벤트리스너","인풋 필드나 셀렉트 박스와 같은 폼 요소 값이 변경될 때 발생합니다.","키보드의 키를 누르는 이벤트를 처리합니다.","키보드의 키를 떼는 이벤트를 처리합니다.","폼이 제출될 때 발생합니다."]},{"i":"12-syntax","l":"1.2. syntax","p":["alt"]},{"l":"2. 버튼추가"},{"i":"21-srccomponentsmemberitemlistjs","l":"2.1. src\\components\\MemberItemList.js","p":["버튼을 클릭 이벤트를 작성합시다.","JSX에서의 이벤트는 onClick 과 같이 on 접두사에 카멜케이스로 이벤트 내용을 작성합니다.","자바스크립트의 onclick 함수와는 다른 react 만의 이벤트 props 입니다.","MDN"]},{"i":"함수-실행방식으로-작성하기","l":"[함수 실행방식으로 작성하기]","p":["버튼을 클릭하면 hey 라는 콘솔 메시지를 확인할수 있습니다.","작성한 코드는 아래의 그림처럼 요약할수 있습니다.","alt"]},{"i":"함수-호출방식으로-작성하기","l":"[함수 호출방식으로 작성하기]","p":["함수를 작성합니다.","컴포넌트는 UI요소만을 즉 태그만을 반환해야 합니다. 지금 작성할 함수는 UI요소가 아니므로 리턴함수는 실행후 다음 라인부터 실행을 하지 않으므로 리턴문 윗줄에 작성합니다. 이벤트 발생시 실행되는 함수이므로 이름을 clickHandler 라고 작성합니다.","이벤트 발생시 함수를 호출합니다.","이벤트 발생시 clickHandler 함수를 호출하므로 소괄호를 넣지 않습니다.","버튼 클릭시 콘솔메시지를 확인할수 있습니다."]},{"i":"왜-소괄호를-하면-안될까요","l":"[왜 소괄호를 하면 안될까요?]","p":["많은 분들이 이벤트 함수 호출시 소괄호를 붙이는지에 대해 헷갈려 합니다.","소괄호를 할경우 실행화면을 살펴보겠습니다.","버튼을 클릭하지 않아도 콘솔 메시지가 출력됩니다. 오히려 클릭할 경우 함수의 호출이 되지 않습니다.","자바스크립트의 경우는 어떨까요? 실행문의 alert 함수로 변경하여 온라인 에디터에서 확인해 보겠습니다.","그럼 리액트는 왜 다른걸까요?","리액트의 태그는 자바스크립트 문법으로 작성되기 때문에 jsx코드가 반환될때 코드의 라인들이 웹브라우저의 해석기에 의해 평가되기 때문입니다.","여기서 평가란 자바스크립트 해석기가 작성된 코드를 분석하여 화면에 표시하거나 오류메시지를 표시하는 과정을 말합니다. 웹브라우저에서 코드를 실행하는 단계와 같습니다.","쉽게 말해 버튼 태그는 자바스크립트에서 html로 해석되는 과정을 거치며 버튼태그에 우리가 작성한 이벤트 함수도 이때 함께 평가 되는 것이죠. 그래서 클릭하지 않아도 실행되는 것입니다.","소괄호를 붙이지 않을경우 clickHandler 함수를 호출하는것이 아닌 버튼에 클릭 이벤트 발생시 clickHandler 함수라는 포인터를 전달하고 리액트에서 기억했다가 클릭할 때마다 함수를 실행하게 됩니다.","그래서 평가될 때 실행되는 것이 아니라 클릭했을 때 실행되게 됩니다."]},{"i":"22-이름-변경","l":"2.2. 이름 변경"},{"i":"221-srccomponentsexpensesexpenseitemjs","l":"2.2.1. src\\components\\Expenses\\ExpenseItem.js","p":["이름을 저장할 변수 선언하고 props.name 을 할당합니다.","콘솔메시지를 확인하여 데이터가 변수에 저장되었는지 확인합니다","clickHandler 함수 호출시 변수 name 의 값을 변경합니다.","클릭시 콘솔창에 새로 변경된 값이 출력되는지 확인합니다","jsx 문장내의 props.name 을 새 변수로 변경합니다.","버튼 클릭시 콘솔창은 새 값이 반환 되는데 왜 화면에는 name의 값이 렌더 되지 않을까요?","이유는 리액트의 컴포넌트 자체가 함수이기 때문입니다.","현재 우리가 작성하고 있는 MemberItemList 컴포넌트 는 함수이며 함수는 호출해야 실행됩니다.","MemberItemList 컴포넌트는 MemberItem 컴포넌트에서 호출하고 있으므로 실행이 되었으며 MemberItemList 내부에서 사용중인 모든 변수나 함수들이 첫 렌더시의 값으로 실행된 것을 볼수 있습니다.","화면의 결과값은 MemberItemList 컴포넌트의 호출결과 이다.","이벤트 함수 호출시 MemberItemList 컴포넌트에서 사용중인 데이터를 변경해서 렌더링 시키려면 MemberItemList 를 한번더 호출해야 합니다.","리액트는 응용프로그램이 처음 렌더링되었을 때 그 모든 과정을 실행하고 그 후에는 끝입니다."]},{"l":"3. useState","p":["리액트의 useState 훅을 사용하여 컴포넌트 내의 값이 변경되면 컴포넌트를 리렌더 할수 있습니다.","useState 처럼 시작단어가 use 로 시작하는 것들을 리액트 HOOK 이라고 합니다.","프로그래밍에서의 후크(Hook), 훅킹(Hooking)이란 이미 작성되어 있는 코드의 특정 지점을 가로채서 동작 방식에 변화를 주는 방식이나 코드를 의미합니다.","리액트의 훅은 클래스 컴포넌트에서 사용하던 기능을 함수형 컴포넌트 에서도 사용할수 있도록 개발된 기능인데요.","제 강의에서는 클래스 컴포넌트를 다루지 않으므로 쉽게 설명 드리자면","컴포넌트에 필요한 복잡한 기능을 리액트에서 쉽게 작성할수 있도록 도와 주는 문법이며 이 문법은 함수형 컴포넌트에만 사용할수 있습니다. 리액트에서는 여러가지 훅을 제공하는데 추후 HOOK만 다룬 강의영상에서 다루기로 하겠습니다.","이번 강의에서는 useState 라는 훅이 있고 이 훅은 함수형 컴포넌트에만 사용할수 있으며 기능은 컴포넌트 내 값 변경시 컴포넌트를 리렌더 할수 있는 기능을 갖고 있다는 점에 집중 하겠습니다."]},{"i":"31-기본문법","l":"3.1. 기본문법","p":["useState 훅은 아래와 같은 문법을 사용하여 작성합니다."]},{"i":"32-작성","l":"3.2. 작성","p":["alt","clickHandler 의 실행문을 작성합니다.","ctrl 키를 누르고 useState함수의 이름을 클릭하면 리액트 모듈에 작성되어 있는 useState 함수가 확인됩니다.","react 모듈로 부터 useState 훅을 임포트 합니다.","return 에 작성불가 (UI요소만 리턴가능)","setName 함수는 name변수의 값을 변경하는 함수입니다.","useState 는 단순히 state 의 값 을 업데이트 하는 것 뿐아니라 값이 변경될때 해당 데이터를 갖고 있는 컴포넌트를 리렌더 하여 화면의 상태에도 변화를 준다는 것을 기억해 주세요","useState 는 함수를 호출합니다.","useState 함수에 인자로 초기값을 전달하면 변수 name 에 할당됩니다.","useState와 반환값을 변수로 저장합니다","배열로 변수의 이름을 작성하고 useState 함수를 할당합니다.","위의 문장을 디스트럭처링으로 줄여서 작성할수 있습니다.","이제 버튼을 클릭하면 이름이 변경됩니다.","컴포넌트 함수 내부에 작성","콘솔창을 확인하면 props 의 name 이 name 변수에 저장 되었습니다.","콘솔창을 확인하면 배열자료형에 두개의 값이 반환되는 것이 보입니다."]},{"l":"Mission","p":["잠깐 영상을 멈추고 버튼을 토글로 구현해 보세요.","한번 클릭시 변경된 값으로 다시한번 클릭시 예전의 값으로 표시해 보십시오."]},{"l":"Solution"}],[{"l":"issue"},{"l":"목차"},{"i":"case1-babelplugin-proposal-private-property-in-object","l":"Case1 @babel/plugin-proposal-private-property-in-object","p":["아래와 같은 메시지가 터미널창에 보일때","One of your dependencies, babel-preset-react-app, is importing the \"@babel/plugin-proposal-private-property-in-object\" package without declaring it in its dependencies. This is currently working because \"@babel/plugin-proposal-private-property-in-object\" is already in your node_modules folder for unrelated reasons, but it may break at any time.","alt"]},{"l":"Cause","p":["해당 오류는 프로젝트의 종속성 중 하나인 babel-preset-react-app이 \"@babel/plugin-proposal-private-property-in-object\" 패키지를 따로 선언하지 않고 사용하고 있기 때문에 발생하는 문제입니다. 현재는 해당 패키지가 다른 이유로 이미 node_modules 폴더에 있어서 문제가 없지만, 잠재적으로 문제를 야기할 요인이 됩니다"]},{"l":"Solution","p":["터미널에 \"@babel/plugin-proposal-private-property-in-object\" 패키지를 프로젝트의 종속성으로 추가하고 node_modules 폴더에 설치하는 명령어 입력합니다 npm install --save @babel/plugin-proposal-private-property-in-object","package.json 파일을 열어 \"dependencies\" 섹션에 \"@babel/plugin-proposal-private-property-in-object\" 패키지가 추가된 것을 확인합니다."]}]]